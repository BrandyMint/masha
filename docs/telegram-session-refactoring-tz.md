# ТЗ: Рефакторинг TelegramSession для устранения избыточных данных

## Общее описание

**Цель:** Минимизировать объем хранимых данных в Telegram сессиях, устранив дублирование информации из БД и снизив риски ошибок.

## Принцип рефакторинга

### Основная идея
**Сессия должна хранить только идентификаторы и временное состояние, а не дублировать данные из БД.**

### Проблема с избыточными данными

**Почему это плохо:**
1. **Источник ошибок** - `original_values` могут быть `nil` или некорректными
2. **Дублирование данных** - те же данные уже есть в БД через `time_shift_id`
3. **Риск рассинхронизации** - данные в сессии могут устареть
4. **Увеличение размера сессии** - лишние данные в Redis/session
5. **Сложность отладки** - нужно проверять два источника данных

### Решение

**Что сделать:**
- Сессия хранит только идентификаторы записей
- Все остальные данные получаем через безопасные методы `find_by`
- Добавить защитные методы для обработки отсутствующих записей

## Правила хранения данных в сессии

### ✅ Что хранить в сессии:
- **Идентификаторы**: `id`, `user_id`, `project_id`
- **Временное состояние**: `field`, `step`, `new_values`
- **Контекст операции**: `operation_type`, `current_action`

### ❌ Что НЕ хранить в сессии:
- **Дублирующие данные**: то что можно получить по ID из БД
- **Оригинальные значения**: все что уже есть в моделях
- **Кэшированные объекты**: целые модели или коллекции

## Алгоритм проверки сессии

### 1. Найти сессии с избыточными данными

**Искать паттерны:**
```ruby
# Плохо - дублирует данные
TelegramSession.edit(time_shift_id: id, original_values: { project_id: x, hours: y })

# Плохо - кэширует объекты
TelegramSession.some_op(project_id: id, project_name: name, project_data: {...})
```

### 2. Создать getter-методы

**Для каждой сессии создать безопасный getter:**
```ruby
# В TelegramSessionHelpers
def edit_time_shift
  return nil unless telegram_session&.type == :edit
  id = telegram_session[:time_shift_id]
  current_user.time_shifts.includes(:project).find_by(id: id)
end
```

### 3. Заменить использование данных

**Было:**
```ruby
project_id = data['original_values']['project_id']
old_project = Project.find(project_id)
```

**Стало:**
```ruby
time_shift = edit_time_shift
return handle_missing_time_shift unless time_shift
project_id = time_shift.project_id
```

### 4. Добавить обработку ошибок

```ruby
def handle_missing_entity
  clear_telegram_session
  respond_with :message, text: 'Сессия устарела. Начните заново.'
end
```

## Примеры рефакторинга

### Edit сессия (уже сделано)

**Было:**
```ruby
TelegramSession.edit(
  time_shift_id: time_shift.id,
  original_values: {
    project_id: time_shift.project_id,
    hours: time_shift.hours,
    description: time_shift.description
  }
)
```

**Стало:**
```ruby
TelegramSession.edit(time_shift_id: time_shift.id)
# Все данные получаем через edit_time_shift()
```

### AddUser сессия (требует проверки)

**Возможные проблемы:**
- Хранит `project_slug` - может быть избыточно
- Возможно хранит `project_name` или другие данные проекта

### AddTime сессия (требует проверки)

**Возможные проблемы:**
- Хранит `project_id` - это правильно (идентификатор)
- Возможно хранит избыточные данные о проекте

## Критерии качества

### ✅ Признаки правильной сессии:
- Размер сессии минимальный
- Все данные можно восстановить по ID
- Нет `original_*` полей
- Используются безопасные `find_by` вместо `find`
- Есть обработка отсутствующих записей

### ❌ Признаки проблемной сессии:
- Есть `original_values`, `old_data`, `cached_*`
- Дублируются поля моделей
- Используются прямые `find()` без проверок
- Большой размер JSON в Redis

## План рефакторинга

### Этап 1: Аудит
1. Найти все фабричные методы `TelegramSession.*`
2. Проанализировать хранимые данные на избыточность
3. Оценить объем каждой сессии в JSON

### Этап 2: Приоритизация
1. **Высокий приоритет**: сессии с `original_values` и `old_*`
2. **Средний приоритет**: сессии с дублированием полей моделей
3. **Низкий приоритет**: сессии с небольшим избыточным данными

### Этап 3: Рефакторинг
1. Создать getter-методы для каждой сессии
2. Обновить все места использования
3. Добавить обработку ошибок
4. Обновить тесты

### Этап 4: Валидация
1. Запустить все тесты
2. Проверить размер сессий в Redis
3. Убедиться в отсутствии регрессий

## Целевые метрики

- **Размер сессии**: уменьшение на 30-70%
- **Ошибки типа "Couldn't find X without ID"**: 0
- **Производительность**: не хуже текущей
- **Тесты**: 100% passing

## Риски и митигация

**Риск:** Race conditions при изменении данных в БД
**Митигация:** Проверка актуальности данных перед сохранением

**Риск:** Увеличение запросов к БД
**Митигация:** Использование `includes` для оптимизации запросов

**Риск:** Сложность миграции
**Митигация:** Пошаговый рефакторинг с обратной совместимостью