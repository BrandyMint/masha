# План рефакторинга системы команд Telegram бота

**Дата:** 2025-10-22
**Статус:** К обсуждению

## Текущая ситуация

### Проблема
- Команды жестко перечислены в `webhook_controller.rb:27` в виде массива:
  ```ruby
  %w[day summary report projects attach start help version users merge add new adduser hours edit rename rate].each do |command|
  ```
- При добавлении новой команды необходимо:
  1. Создать файл команды
  2. Добавить имя команды в массив в контроллере
- Риск человеческой ошибки (забыть добавить команду в список)

### Существующая архитектура
- ✅ Есть `BaseCommand` с общим интерфейсом
- ✅ Команды следуют паттерну `#{command}!` → `#{command.camelize}Command`
- ✅ Все команды лежат в `app/controllers/telegram/commands/*_command.rb`

## Предлагаемый рефакторинг

### Шаг 1. Создание реестра команд

**Файл:** `app/controllers/telegram/commands/registry.rb`

**Класс:** `Telegram::Commands::Registry`

**Функциональность:**
- Автоматическое сканирование папки с командами
- Динамическая регистрация найденных классов
- Методы:
  - `commands` - массив доступных команд
  - `command_class(name)` - получить класс команды по имени
  - `reload!` - перезагрузка реестра (для разработки)

### Шаг 2. Обновление webhook_controller.rb

**Текущий код:**
```ruby
%w[day summary report projects attach start help version users merge add new adduser hours edit rename rate].each do |command|
  define_method "#{command}!" do |*args|
    command_class = "Telegram::Commands::#{command.camelize}Command".constantize
    command_class.new(self).call(*args)
  end
end
```

**Новый код:**
```ruby
Telegram::Commands::Registry.commands.each do |command|
  define_method "#{command}!" do |*args|
    command_class = Telegram::Commands::Registry.command_class(command)
    command_class.new(self).call(*args)
  end
end
```

### Шаг 3. Улучшение BaseCommand (опционально)

Добавить возможность самоопределения имени команды:
```ruby
class BaseCommand
  def self.command_name
    name.demodulize.underscore.gsub('_command', '')
  end
end
```

## Преимущества подхода

### Для разработчиков
- **Автоматическое добавление**: создал файл → команда доступна
- **Нет дублирования**: не нужно обновлять два места
- **Меньше ошибок**: исключен человеческий фактор

### Для системы
- **Единая точка правды**: реестр знает все команды
- **Горячая перезагрузка**: возможность `reload!` в development
- **Расширяемость**: легко добавить метаданные, права доступа и т.д.

## Обратная совместимость

- ✅ Сохранение текущего API вызова команд
- ✅ Плавный переход без изменения логики
- ✅ Все существующие команды продолжают работать

## Порядок реализации

1. **Создание Registry** с базовым функционалом
2. **Тестирование реестра** на существующих командах
3. **Обновление webhook_controller.rb**
4. **Проверка работоспособности** всех команд
5. **Добавление тестов** для новой архитектуры
6. **Обновление документации** по созданию команд

## Альтернативные подходы

### 1. Convention-based (более простой)
Имя файла напрямую соответствует команде без дополнительной регистрации

### 2. Registration-based (более явный)
Явная регистрация в инициализаторе приложения

### 3. Gem-based
Использование готовых решений типа `telegram-bot`

## Риски и митигация

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Поломка существующих команд | Низкая | Высокое | Тестирование на всех командах |
| Проблемы с загрузкой классов | Средняя | Среднее | Обработка ошибок в реестре |
| Снижение производительности | Низкая | Низкое | Кеширование списка команд |

## Вопросы для обсуждения

1. **Нужен ли BaseCommand улучшения** или оставляем как есть?
2. **Как обрабатывать ошибки загрузки команд** - падать или логгировать?
3. **Нужна ли горячая перезагрузка** в development режиме?
4. **Стоит ли добавлять метаданные** (описание, права доступа) в реестр?

## Следующие шаги

1. Получить фидбек по плану
2. Выбрать финальную архитектуру
3. Реализовать в несколько итераций с тестированием на каждом шаге